{\rtf1\ansi\ansicpg1252\cocoartf1504\cocoasubrtf830
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 \
\
1. The graph is stored and represented as an adjacency list. \
\
2. 2 and 3 are connected. The output for these two graphs when run in the program\'92s main function with BFS and DFS shows that each vertex has a path to all other vertexes in the graph. Thus the graphs 2 and 3 are connected. \
\
3.Reversing the graph would result in the same output for an undirected graph becaus edges can be traveled in either direction. If the graph was a directed graph and the path were reversed the output would change because the edges the accessible edges would be different based on different source and destination vertecies. \
\
4. DFS can get stuck in a repeting path and BFS will not. DFS may be faster if it gets lucky and finds the solution early in it\'92s search however it may also have to backtrack which can make it run much slower. Essentially DFS can be faster but it is also variable in time expense. BFS will search all paths if they exist and find the shortest path, whereas DFS may find the solution but not necessarily find the shortest path to the solution. BFS uses much more memory than a DFS but it also has the benefit of exploring all nodes which can be useful for things like comparisons. \
\
5. The time complexity for both searches is O(n) such that n is the total number of edges in the graph.}